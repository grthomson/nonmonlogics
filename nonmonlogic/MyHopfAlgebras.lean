/-
  MyHopfAlgebras.lean
  ---
  This is where I’ll start building some examples and structures related to Hopf algebras.
  I’m following Mathlib’s HopfAlgebra API, but I’ll also set up my own combinatorial
  objects (trees, forests, etc.) that I’ll later use to define specific Hopf algebras.
-/

import Mathlib/RingTheory/HopfAlgebra/Basic
import Mathlib/Data/Multiset
import Mathlib/Data/Finsupp/Basic
import Mathlib/Algebra/Algebra/TensorProduct

set_option autoImplicit true

namespace MyHopf

/-! ## General setup -/

-- I’ll work over a fixed commutative semiring R.
variable {R : Type*} [CommSemiring R]

-- I’ll also allow trees with leaves labeled by some type α.
variable {α : Type*}

/-! ## Trees and forests

I’ll start with **planar binary trees**, then quotient by swapping children
to get the **non-planar trees** that appear in the paper.
-/

inductive PTree (α : Type*) : Type*
| leaf : α → PTree
| node : PTree → PTree → PTree
deriving DecidableEq

namespace PTree
variable {α}

/-- Swapping the two subtrees of a node. -/
def swap : PTree α → PTree α
| leaf a   => leaf a
| node l r => node r l

/-- The equivalence relation generated by swapping children. -/
inductive SwapRel : PTree α → PTree α → Prop
| refl  : ∀ t, SwapRel t t
| symm  : ∀ {s t}, SwapRel s t → SwapRel t s
| trans : ∀ {r s t}, SwapRel r s → SwapRel s t → SwapRel r t
| comp_left  : ∀ {l l' r}, SwapRel l l' → SwapRel (.node l r) (.node l' r)
| comp_right : ∀ {l r r'}, SwapRel r r' → SwapRel (.node l r) (.node l r')
| swap_node  : ∀ {l r}, SwapRel (.node l r) (.node r l)

end PTree

/-- My **non-planar trees** are planar trees modulo swapping of children. -/
def Tree (α : Type*) : Type* := Quot (@PTree.SwapRel α)

/-- A **forest** is just a finite multiset of trees. -/
abbrev Forest (α : Type*) := Multiset (Tree α)

/-! ## Linear combinations of forests

I’ll model formal finite ℤ-linear combinations of forests with `Finsupp`.
Later, I can generalize to an arbitrary base ring `R`.
-/

abbrev ZLin (α : Type*) := Forest α →₀ ℤ
abbrev RLin (R α : Type*) [Semiring R] := Forest α →₀ R

/-- Tensor product of two copies of the R-linear space of forests. -/
abbrev RTensor (R α : Type*) [Semiring R] :=
  TensorProduct R (RLin R α) (RLin R α)

/-! ## Notes to myself

Next steps:
1. Define `accessible : Tree α → Finset (Tree α)` and extend it to forests.
2. Define `quotientBy : Tree α → Tree α → Tree α` corresponding to the T/T_v operation.
3. Define `Delta : RLin R α →ₗ[R] RTensor R α` by linear extension from generators.
4. Later, prove the bialgebra and Hopf-algebra properties and connect everything
   with Mathlib’s `Bialgebra` and `HopfAlgebra` classes.
-/

/-! ## Hooking into Mathlib’s HopfAlgebra API

Once I have:
  * an R-algebra on some carrier A,
  * comultiplication and counit maps,
  * and proofs of the bialgebra axioms,

I’ll be able to register instances like this:
-/

noncomputable
def myComul (A : Type*) [Semiring A] [Algebra R A] : A →ₗ[R] A ⊗[R] A := by
  -- TODO: define this later, starting from generators
  exact 0

noncomputable
def myCounit (A : Type*) [Semiring A] [Algebra R A] : A →ₗ[R] R := by
  -- TODO: define this later as well
  exact 0

-- Eventually, when the axioms are in place:
-- noncomputable
-- instance (A : Type*) [Semiring A] [Algebra R A] : Bialgebra R A := by
--   apply Bialgebra.mk'
--   sorry  -- proofs of the four bialgebra laws

end MyHopf
